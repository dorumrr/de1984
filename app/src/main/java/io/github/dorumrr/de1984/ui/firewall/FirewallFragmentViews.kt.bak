package io.github.dorumrr.de1984.ui.firewall

import android.content.Context
import android.content.res.ColorStateList
import android.os.Bundle
import android.telephony.TelephonyManager
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import kotlinx.coroutines.launch
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.chip.Chip
import com.google.android.material.switchmaterial.SwitchMaterial
import io.github.dorumrr.de1984.De1984Application
import io.github.dorumrr.de1984.R
import io.github.dorumrr.de1984.databinding.BottomSheetPackageActionGranularBinding
import io.github.dorumrr.de1984.databinding.BottomSheetPackageActionSimpleBinding
import io.github.dorumrr.de1984.databinding.FragmentFirewallBinding
import io.github.dorumrr.de1984.databinding.NetworkTypeToggleBinding
import io.github.dorumrr.de1984.domain.model.NetworkPackage
import io.github.dorumrr.de1984.presentation.viewmodel.FirewallViewModel
import io.github.dorumrr.de1984.presentation.viewmodel.SettingsViewModel
import io.github.dorumrr.de1984.ui.base.BaseFragment
import io.github.dorumrr.de1984.ui.common.FilterChipsHelper
import io.github.dorumrr.de1984.utils.Constants
import io.github.dorumrr.de1984.utils.openAppSettings
import kotlinx.coroutines.launch
import androidx.core.widget.addTextChangedListener

/**
 * Firewall Fragment using XML Views
 * 
 * Features:
 * - Filter chips for package type and network state
 * - RecyclerView with network packages
 * - Click to toggle allow/block
 * - Empty and loading states
 */
class FirewallFragmentViews : BaseFragment<FragmentFirewallBinding>() {

    private val TAG = "FirewallFragmentViews"

    private val viewModel: FirewallViewModel by viewModels {
        val app = requireActivity().application as De1984Application
        FirewallViewModel.Factory(
            app,
            app.dependencies.provideGetNetworkPackagesUseCase(),
            app.dependencies.provideManageNetworkAccessUseCase(),
            app.dependencies.superuserBannerState,
            app.dependencies.permissionManager,
            app.dependencies.firewallManager
        )
    }

    private val settingsViewModel: SettingsViewModel by viewModels {
        val app = requireActivity().application as De1984Application
        SettingsViewModel.Factory(
            requireContext(),
            app.dependencies.permissionManager,
            app.dependencies.rootManager,
            app.dependencies.shizukuManager,
            app.dependencies.firewallManager,
            app.dependencies.firewallRepository
        )
    }

    private lateinit var adapter: NetworkPackageAdapter
    private var currentTypeFilter: String? = null
    private var currentStateFilter: String? = null
    private var currentPermissionFilter: Boolean = false
    private var lastSubmittedPackages: List<NetworkPackage> = emptyList()

    override fun getViewBinding(
        inflater: LayoutInflater,
        container: ViewGroup?
    ) = FragmentFirewallBinding.inflate(inflater, container, false)

    override fun scrollToTop() {
        // Only scroll if binding is available (fragment view is created)
        _binding?.packagesRecyclerView?.scrollToPosition(0)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Show loading state immediately until first state emission
        binding.loadingState.visibility = View.VISIBLE
        binding.emptyState.visibility = View.GONE
        binding.packagesRecyclerView.visibility = View.GONE

        setupRecyclerView()
        setupFilterChips()
        setupSearchBox()
        observeUiState()
        observeSettingsState()

        // Refresh default policy on start
        viewModel.refreshDefaultPolicy()
    }

    private fun setupRecyclerView() {
        adapter = NetworkPackageAdapter(
            showIcons = true, // Will be updated from settings
            onPackageClick = { pkg ->
                showPackageActionSheet(pkg)
            }
        )

        binding.packagesRecyclerView.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = this@FirewallFragmentViews.adapter
            setHasFixedSize(true)
        }
    }

    private fun setupFilterChips() {
        // Initial setup - only called once
        currentTypeFilter = "User"
        currentStateFilter = null
        currentPermissionFilter = false

        FilterChipsHelper.setupMultiSelectFilterChips(
            chipGroup = binding.filterChips,
            typeFilters = Constants.Firewall.PACKAGE_TYPE_FILTERS,
            stateFilters = Constants.Firewall.NETWORK_STATE_FILTERS,
            permissionFilters = Constants.Firewall.PERMISSION_FILTERS,
            selectedTypeFilter = currentTypeFilter,
            selectedStateFilter = currentStateFilter,
            selectedPermissionFilter = currentPermissionFilter,
            onTypeFilterSelected = { filter ->
                if (filter != currentTypeFilter) {
                    currentTypeFilter = filter
                    viewModel.setPackageTypeFilter(filter)
                }
            },
            onStateFilterSelected = { filter ->
                if (filter != currentStateFilter) {
                    currentStateFilter = filter
                    viewModel.setNetworkStateFilter(filter)
                }
            },
            onPermissionFilterSelected = { enabled ->
                if (enabled != currentPermissionFilter) {
                    currentPermissionFilter = enabled
                    viewModel.setInternetOnlyFilter(enabled)
                }
            }
        )
    }

    private fun setupSearchBox() {
        // Text change listener for real-time search
        binding.searchInput.addTextChangedListener { text ->
            val query = text?.toString() ?: ""
            viewModel.setSearchQuery(query)
        }

        // Handle keyboard "Search" or "Done" button
        binding.searchInput.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == android.view.inputmethod.EditorInfo.IME_ACTION_SEARCH) {
                hideKeyboardAndClearFocus()
                true
            } else {
                false
            }
        }

        // Clear focus and hide keyboard when touching/scrolling RecyclerView
        binding.packagesRecyclerView.setOnTouchListener { view, event ->
            if (event.action == android.view.MotionEvent.ACTION_DOWN) {
                if (binding.searchInput.hasFocus()) {
                    hideKeyboardAndClearFocus()
                    view.requestFocus()
                }
            }
            false // Allow touch events to propagate for normal scrolling
        }

        // Clear focus when scrolling RecyclerView
        binding.packagesRecyclerView.addOnScrollListener(object : androidx.recyclerview.widget.RecyclerView.OnScrollListener() {
            override fun onScrollStateChanged(recyclerView: androidx.recyclerview.widget.RecyclerView, newState: Int) {
                if (newState == androidx.recyclerview.widget.RecyclerView.SCROLL_STATE_DRAGGING) {
                    if (binding.searchInput.hasFocus()) {
                        hideKeyboardAndClearFocus()
                    }
                }
            }
        })

        // Clear focus when clicking on root container (outside search box)
        binding.rootContainer.setOnTouchListener { view, event ->
            if (event.action == android.view.MotionEvent.ACTION_DOWN) {
                // Check if touch is outside the search layout
                val searchLayoutLocation = IntArray(2)
                binding.searchLayout.getLocationOnScreen(searchLayoutLocation)
                val searchLayoutRect = android.graphics.Rect(
                    searchLayoutLocation[0],
                    searchLayoutLocation[1],
                    searchLayoutLocation[0] + binding.searchLayout.width,
                    searchLayoutLocation[1] + binding.searchLayout.height
                )

                val touchX = event.rawX.toInt()
                val touchY = event.rawY.toInt()

                if (!searchLayoutRect.contains(touchX, touchY) && binding.searchInput.hasFocus()) {
                    hideKeyboardAndClearFocus()
                    view.requestFocus()
                }
            }
            false // Allow touch events to propagate
        }
    }

    private fun hideKeyboardAndClearFocus() {
        binding.searchInput.clearFocus()
        val imm = requireContext().getSystemService(android.content.Context.INPUT_METHOD_SERVICE) as? android.view.inputmethod.InputMethodManager
        imm?.hideSoftInputFromWindow(binding.searchInput.windowToken, 0)
    }

    private fun updateFilterChips(
        packageTypeFilter: String,
        networkStateFilter: String?,
        internetOnlyFilter: Boolean
    ) {
        // Only update if filters have changed
        if (packageTypeFilter == currentTypeFilter &&
            networkStateFilter == currentStateFilter &&
            internetOnlyFilter == currentPermissionFilter) {
            return
        }

        currentTypeFilter = packageTypeFilter
        currentStateFilter = networkStateFilter
        currentPermissionFilter = internetOnlyFilter

        // Update chip selection without recreating or triggering listeners
        FilterChipsHelper.updateMultiSelectFilterChips(
            chipGroup = binding.filterChips,
            selectedTypeFilter = packageTypeFilter,
            selectedStateFilter = networkStateFilter,
            selectedPermissionFilter = internetOnlyFilter
        )
    }

    private fun observeUiState() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    updateUI(state)
                }
            }
        }
    }

    private fun observeSettingsState() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                settingsViewModel.uiState.collect { settingsState ->
                    // Update adapter when showIcons setting changes
                    adapter = NetworkPackageAdapter(
                        showIcons = settingsState.showAppIcons,
                        onPackageClick = { pkg ->
                            showPackageActionSheet(pkg)
                        }
                    )
                    binding.packagesRecyclerView.adapter = adapter
                    // Re-submit current list
                    viewModel.uiState.value.packages.let { packages ->
                        adapter.submitList(packages)
                    }
                }
            }
        }
    }

    private fun updateUI(state: io.github.dorumrr.de1984.presentation.viewmodel.FirewallUiState) {
        // Update visibility based on state
        if (state.isLoadingData && state.packages.isEmpty()) {
            binding.packagesRecyclerView.visibility = View.INVISIBLE  // INVISIBLE instead of GONE
            binding.loadingState.visibility = View.VISIBLE
            binding.emptyState.visibility = View.GONE
        } else if (state.packages.isEmpty()) {
            binding.packagesRecyclerView.visibility = View.INVISIBLE
            binding.loadingState.visibility = View.GONE
            binding.emptyState.visibility = View.VISIBLE
        } else {
            binding.packagesRecyclerView.visibility = View.VISIBLE
            binding.loadingState.visibility = View.GONE
            binding.emptyState.visibility = View.GONE
        }

        // Update filter chips
        updateFilterChips(
            packageTypeFilter = state.filterState.packageType,
            networkStateFilter = state.filterState.networkState,
            internetOnlyFilter = state.filterState.internetOnly
        )

        // Apply search filtering with partial substring matching (app name only)
        val displayedPackages = if (state.searchQuery.isBlank()) {
            state.packages
        } else {
            val query = state.searchQuery.lowercase()
            state.packages.filter { pkg ->
                pkg.name.lowercase().contains(query, ignoreCase = false)
            }
        }

        // Update RecyclerView only if list changed
        val listChanged = displayedPackages != lastSubmittedPackages
        if (!listChanged) {
            return
        }

        lastSubmittedPackages = displayedPackages
        adapter.submitList(displayedPackages)
        if (state.isRenderingUI) {
            viewModel.setUIReady()
        }
    }

    /**
     * Open the firewall dialog for a specific app by package name.
     * Used for cross-navigation from other screens.
     */
    fun openAppDialog(packageName: String) {
        Log.d(TAG, "[FIREWALL] openAppDialog called for: $packageName")
        
        // Find the package in the current list
        val pkg = viewModel.uiState.value.packages.find { it.packageName == packageName }
        
        if (pkg != null) {
            Log.d(TAG, "[FIREWALL] Package found: ${pkg.name}, opening dialog")
            showPackageActionSheet(pkg)
        } else {
            Log.w(TAG, "[FIREWALL] Package not found in list. Total packages: ${viewModel.uiState.value.packages.size}")
            
            // If package not found, wait for data to load and try again
            lifecycleScope.launch {
                viewModel.uiState.collect { state ->
                    Log.d(TAG, "[FIREWALL] Waiting for data... Current packages: ${state.packages.size}")
                    val foundPkg = state.packages.find { it.packageName == packageName }
                    if (foundPkg != null) {
                        Log.d(TAG, "[FIREWALL] Package found after waiting: ${foundPkg.name}")
                        showPackageActionSheet(foundPkg)
                        return@collect // Stop collecting once found
                    }
                }
            }
        }
    }

    private fun showPackageActionSheet(pkg: NetworkPackage) {
        val dialog = BottomSheetDialog(requireContext())

        // Get FirewallManager from application dependencies
        val app = requireActivity().application as De1984Application
        val firewallManager = app.dependencies.firewallManager

        // Check if current backend supports granular control
        val supportsGranular = firewallManager.supportsGranularControl()

        if (supportsGranular) {
            showGranularControlSheet(dialog, pkg)
        } else {
            showSimpleControlSheet(dialog, pkg)
        }
    }

    private fun showGranularControlSheet(dialog: BottomSheetDialog, pkg: NetworkPackage) {
        val binding = BottomSheetPackageActionGranularBinding.inflate(layoutInflater)

        // Check if device has cellular capability
        val telephonyManager = requireContext().getSystemService(Context.TELEPHONY_SERVICE) as? TelephonyManager
        val hasCellular = telephonyManager?.phoneType != TelephonyManager.PHONE_TYPE_NONE

        // Setup header
        try {
            val pm = requireContext().packageManager
            val appInfo = pm.getApplicationInfo(pkg.packageName, 0)
            val icon = pm.getApplicationIcon(appInfo)
            binding.actionSheetAppIcon.setImageDrawable(icon)
        } catch (e: Exception) {
            binding.actionSheetAppIcon.setImageResource(R.drawable.de1984_icon)
        }
        binding.actionSheetAppName.text = pkg.name
        binding.actionSheetPackageName.text = pkg.packageName

        // Click app icon to open Android system settings
        binding.actionSheetAppIcon.setOnClickListener {
            requireContext().openAppSettings(pkg.packageName)
            dialog.dismiss()
        }

        // Always show roaming toggle if device has cellular
        if (hasCellular) {
            binding.roamingDivider.visibility = View.VISIBLE
            binding.roamingToggle.root.visibility = View.VISIBLE
        } else {
            binding.roamingDivider.visibility = View.GONE
            binding.roamingToggle.root.visibility = View.GONE
        }

        // Flag to prevent infinite recursion when updating switches programmatically
        var isUpdatingProgrammatically = false

        // Function to update UI toggles based on current package state
        fun updateTogglesFromPackage(currentPkg: NetworkPackage) {
            isUpdatingProgrammatically = true

            // Update WiFi toggle
            binding.wifiToggle.toggleSwitch.isChecked = currentPkg.wifiBlocked
            updateSwitchColors(binding.wifiToggle.toggleSwitch, currentPkg.wifiBlocked)

            // Update Mobile toggle
            binding.mobileToggle.toggleSwitch.isChecked = currentPkg.mobileBlocked
            updateSwitchColors(binding.mobileToggle.toggleSwitch, currentPkg.mobileBlocked)

            // Update Roaming toggle (if device has cellular)
            if (hasCellular) {
                binding.roamingToggle.toggleSwitch.isChecked = currentPkg.roamingBlocked
                updateSwitchColors(binding.roamingToggle.toggleSwitch, currentPkg.roamingBlocked)
            }

            isUpdatingProgrammatically = false
        }

        // Initial setup of toggles
        updateTogglesFromPackage(pkg)

        // Observe package changes to update UI when ViewModel makes cascading changes
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                val updatedPkg = state.packages.find { it.packageName == pkg.packageName }
                if (updatedPkg != null && !isUpdatingProgrammatically) {
                    updateTogglesFromPackage(updatedPkg)
                }
            }
        }

        // Setup WiFi toggle
        setupNetworkToggle(
            binding = binding.wifiToggle,
            label = "WiFi",
            isBlocked = pkg.wifiBlocked,
            enabled = !pkg.isSystemCritical && !pkg.isVpnApp,
            onToggle = { blocked ->
                if (isUpdatingProgrammatically) return@setupNetworkToggle
                viewModel.setWifiBlocking(pkg.packageName, blocked)
            }
        )

        // Setup Mobile Data toggle
        setupNetworkToggle(
            binding = binding.mobileToggle,
            label = "Mobile Data",
            isBlocked = pkg.mobileBlocked,
            enabled = !pkg.isSystemCritical && !pkg.isVpnApp,
            onToggle = { blocked ->
                if (isUpdatingProgrammatically) return@setupNetworkToggle

                // ViewModel handles mobile+roaming dependency atomically
                viewModel.setMobileBlocking(pkg.packageName, blocked)
            }
        )

        // Setup Roaming toggle (only if device has cellular)
        if (hasCellular) {
            setupNetworkToggle(
                binding = binding.roamingToggle,
                label = "Roaming",
                isBlocked = pkg.roamingBlocked,
                enabled = !pkg.isSystemCritical && !pkg.isVpnApp,
                onToggle = { blocked ->
                    if (isUpdatingProgrammatically) return@setupNetworkToggle

                    // ViewModel handles mobile+roaming dependency atomically
                    viewModel.setRoamingBlocking(pkg.packageName, blocked)
                }
            )
        }

        // Show info message
        val app = requireActivity().application as De1984Application
        val firewallManager = app.dependencies.firewallManager
        val backendType = firewallManager.getActiveBackendType()

        if (pkg.isSystemCritical) {
            binding.infoMessage.visibility = View.VISIBLE
            binding.infoMessage.text = "âš ï¸ System Critical Package - Network access cannot be modified to prevent system instability."
        } else if (pkg.isVpnApp) {
            binding.infoMessage.visibility = View.VISIBLE
            binding.infoMessage.text = "ðŸ”’ VPN App - Always allowed to prevent VPN reconnection issues after device lock/unlock."
        } else if (backendType == io.github.dorumrr.de1984.domain.firewall.FirewallBackendType.VPN) {
            binding.infoMessage.visibility = View.VISIBLE
            binding.infoMessage.text = "Using VPN-based firewall because your device is not rooted or doesn't have Shizuku. You cannot use another VPN app while De1984 Firewall is active."
        } else {
            binding.infoMessage.visibility = View.GONE
        }

        // Cross-navigation button to Packages screen
        binding.actionSheetManageAppButton.setOnClickListener {
            Log.d(TAG, "[FIREWALL] Manage App button clicked for: ${pkg.packageName}")
            dialog.dismiss()
            (requireActivity() as? io.github.dorumrr.de1984.ui.MainActivity)?.navigateToPackagesWithApp(pkg.packageName)

        dialog.setContentView(binding.root)
        dialog.show()
    }

    private fun showSimpleControlSheet(dialog: BottomSheetDialog, pkg: NetworkPackage) {
        val binding = BottomSheetPackageActionSimpleBinding.inflate(layoutInflater)

        // Setup header
        try {
            val pm = requireContext().packageManager
            val appInfo = pm.getApplicationInfo(pkg.packageName, 0)
            val icon = pm.getApplicationIcon(appInfo)
            binding.actionSheetAppIcon.setImageDrawable(icon)
        } catch (e: Exception) {
            binding.actionSheetAppIcon.setImageResource(R.drawable.de1984_icon)
        }
        binding.actionSheetAppName.text = pkg.name
        binding.actionSheetPackageName.text = pkg.packageName

        // Click app icon to open Android system settings
        binding.actionSheetAppIcon.setOnClickListener {
            requireContext().openAppSettings(pkg.packageName)
            dialog.dismiss()
        }

        // Set appropriate info message based on package type and backend
        val app = requireActivity().application as De1984Application
        val firewallManager = app.dependencies.firewallManager
        val backendType = firewallManager.getActiveBackendType()

        val infoMessage = if (pkg.isSystemCritical) {
            "âš ï¸ System Critical Package - Network access cannot be modified to prevent system instability."
        } else if (pkg.isVpnApp) {
            "ðŸ”’ VPN App - Always allowed to prevent VPN reconnection issues after device lock/unlock."
        } else {
            when (backendType) {
                io.github.dorumrr.de1984.domain.firewall.FirewallBackendType.CONNECTIVITY_MANAGER -> {
                    "This blocks all network types (WiFi, Mobile, Roaming).\n\n" +
                    "Your device uses a system-level firewall that doesn't support per-network blocking. " +
                    "For granular control, root access is required."
                }
                else -> {
                    "This blocks all network types (WiFi, Mobile, Roaming)."
                }
            }
        }
        binding.infoMessage.text = infoMessage

        // Flag to prevent infinite recursion when updating switch programmatically
        var isUpdatingProgrammatically = false

        // Function to update UI toggle based on current package state
        fun updateToggleFromPackage(currentPkg: NetworkPackage) {
            isUpdatingProgrammatically = true

            // For all-or-nothing backends, check if ANY network is blocked
            val isBlocked = currentPkg.wifiBlocked || currentPkg.mobileBlocked || currentPkg.roamingBlocked
            binding.internetToggle.toggleSwitch.isChecked = isBlocked
            updateSwitchColors(binding.internetToggle.toggleSwitch, isBlocked)

            isUpdatingProgrammatically = false
        }

        // Initial setup of toggle
        updateToggleFromPackage(pkg)

        // Observe package changes to update UI when ViewModel makes changes
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                val updatedPkg = state.packages.find { it.packageName == pkg.packageName }
                if (updatedPkg != null && !isUpdatingProgrammatically) {
                    updateToggleFromPackage(updatedPkg)
                }
            }
        }

        // Setup single "Block Internet" toggle
        setupNetworkToggle(
            binding = binding.internetToggle,
            label = "Block Internet",
            isBlocked = pkg.wifiBlocked || pkg.mobileBlocked || pkg.roamingBlocked,
            enabled = !pkg.isSystemCritical && !pkg.isVpnApp,
            onToggle = { blocked ->
                if (isUpdatingProgrammatically) return@setupNetworkToggle

                // Block/unblock ALL networks at once atomically - prevents race conditions
                viewModel.setAllNetworkBlocking(pkg.packageName, blocked)
            }
        )

        // Cross-navigation button to Packages screen
        binding.actionSheetManageAppButton.setOnClickListener {
            Log.d(TAG, "[FIREWALL] Manage App button clicked for: ${pkg.packageName}")
            dialog.dismiss()
        }

        dialog.setContentView(binding.root)
        dialog.show()
    }

    private fun setupNetworkToggle(
        binding: NetworkTypeToggleBinding,
        label: String,
        isBlocked: Boolean,
        enabled: Boolean,
        onToggle: (Boolean) -> Unit
    ) {
        binding.networkTypeLabel.text = label

        // Set initial state: switch ON = blocked, switch OFF = allowed
        binding.toggleSwitch.isChecked = isBlocked
        binding.toggleSwitch.isEnabled = enabled

        // Update colors based on state
        updateSwitchColors(binding.toggleSwitch, isBlocked)

        // Simple switch listener - only fires on user interaction
        binding.toggleSwitch.setOnCheckedChangeListener { _, isChecked ->
            updateSwitchColors(binding.toggleSwitch, isChecked)
            onToggle(isChecked)
        }
    }

    private fun updateSwitchColors(switch: SwitchMaterial, @Suppress("UNUSED_PARAMETER") isBlocked: Boolean) {
        val context = switch.context

        // Create color state lists for checked (blocked/ON) and unchecked (allowed/OFF) states
        val thumbColorStateList = ColorStateList(
            arrayOf(
                intArrayOf(android.R.attr.state_checked),  // When switch is ON (blocked)
                intArrayOf(-android.R.attr.state_checked)  // When switch is OFF (allowed)
            ),
            intArrayOf(
                ContextCompat.getColor(context, R.color.error_red),      // RED when blocked (ON)
                ContextCompat.getColor(context, R.color.lineage_teal)   // TEAL when allowed (OFF)
            )
        )

        val trackColorStateList = ColorStateList(
            arrayOf(
                intArrayOf(android.R.attr.state_checked),  // When switch is ON (blocked)
                intArrayOf(-android.R.attr.state_checked)  // When switch is OFF (allowed)
            ),
            intArrayOf(
                ContextCompat.getColor(context, R.color.error_red) and 0x80FFFFFF.toInt(),      // RED with 50% opacity when blocked (ON)
                ContextCompat.getColor(context, R.color.lineage_teal) and 0x80FFFFFF.toInt()   // TEAL with 50% opacity when allowed (OFF)
            )
        )

        // Set thumb (the circle) and track (the background) colors
        switch.thumbTintList = thumbColorStateList
        switch.trackTintList = trackColorStateList
    }

    companion object {
        private const val TAG = "FirewallFragmentViews"
    }
}

